# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ty7zdvpdQf6cOwgFDUCWbfetuocEVpcx
"""

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-5, 5, 100)
y = x**2

plt.plot(x, y, label='Funkcja celu')
plt.xlabel('Parametr')
plt.ylabel('Wartość funkcji celu')
plt.legend()
plt.show()

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-5, 5, 100)
y = x**2

# Symulacja trajektorii optymalizacji
optimization_path = np.array([[-4, 16], [-3, 9], [-2, 4], [-1, 1], [0, 0]])

plt.plot(x, y, label='Funkcja celu')
plt.scatter(optimization_path[:, 0], optimization_path[:, 1], color='red', label='Trajektoria optymalizacji')
plt.xlabel('Parametr')
plt.ylabel('Wartość funkcji celu')
plt.legend()
plt.show()

import numpy as np

def bisection(df, lower, upper, tol):
    iteracja = 1
    while (upper - lower > 2 * tol):
        print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
        m = (lower + upper) / 2
        df_m = df(m)

        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)

        if df_m < 0:
            lower = m
        else:
            upper = m

        iteracja += 1

    print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
    return (upper + lower) / 2

import numpy as np
import matplotlib.pyplot as plt

# Definicja funkcji
def f6(x):
    return (x**3 - 3) * np.exp(x)

def mf6(x):
    return -(x**3 - 3) * np.exp(x)

def df6(x):
    return np.exp(x) * (x**3 + 3*x**2 - 3)

def mdf6(x):
    return -np.exp(x) * (x**3 + 3*x**2 - 3)

# Implementacja metody bisekcji
def bisection(df, lower, upper, tol):
    iteracja = 1
    while (upper - lower > 2 * tol):
        print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
        m = (lower + upper) / 2
        df_m = df(m)

        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)

        if df_m < 0:
            lower = m
        else:
            upper = m

        iteracja += 1

    print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
    return (upper + lower) / 2

# Wykresy funkcji
x_vals = np.linspace(-5, 2, 100)
plt.plot(x_vals, f6(x_vals), label='f6(x)')
plt.ylim(-6, 5)
plt.title('Wykres funkcji f6(x)')
plt.show()

x_vals_mf6 = np.linspace(-7, 2, 100)
plt.plot(x_vals_mf6, mf6(x_vals_mf6), label='mf6(x)')
plt.ylim(-5, 6)
plt.title('Wykres funkcji mf6(x)')
plt.show()

# Wywołanie metody bisekcji dla df6 i mdf6
bisection_result_df6 = bisection(df6, 0, 2, 0.001)
print("Wynik dla df6:", bisection_result_df6)

bisection_result_mdf6 = bisection(mdf6, -2.5, 0, 0.001)
print("Wynik dla mdf6:", bisection_result_mdf6)

import numpy as np

def bisection(df, lower, upper, tol):
    iteracja = 1
    while (upper - lower > 2 * tol):
        print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
        m = (lower + upper) / 2
        df_m = df(m)

        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)

        if df_m < 0:
            lower = m
        else:
            upper = m

        iteracja += 1

    print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
    return (upper + lower) / 2

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation

x = np.linspace(-5, 5, 100)
y = x**2

fig, ax = plt.subplots()
line, = ax.plot(x, y, label='Funkcja celu')
points, = ax.plot([], [], 'ro', label='Trajektoria optymalizacji')

def update(frame):
    points.set_data(optimization_path[:frame, 0], optimization_path[:frame, 1])
    return points,

ani = FuncAnimation(fig, update, frames=len(optimization_path), blit=True)
plt.legend()
plt.show()





import numpy as np
import matplotlib.pyplot as plt
def f6(x):
    return (x**3 - 3) * np.exp(x)
def mf6(x):
    return -(x**3 - 3) * np.exp(x)
def df6(x):
    return np.exp(x) * (x**3 + 3*x**2 - 3)
def mdf6(x):
    return -np.exp(x) * (x**3 + 3*x**2 - 3)
# Implementacja metody bisekcji
def bisection(df, lower, upper, tol):
    iteracja = 1
    while (upper - lower > 2 * tol):
        print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
        m = (lower + upper) / 2
        df_m = df(m)
        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)
        if df_m < 0:
            lower = m
        else:
            upper = m
        iteracja += 1
    print("iteracja nr: {}, a= {}, b= {}".format(iteracja, lower, upper))
    return (upper + lower) / 2
# Wykresy funkcji
x_vals = np.linspace(-5, 2, 100)
plt.plot(x_vals, f6(x_vals), label='f6(x)')
plt.ylim(-6, 5)
plt.title('Wykres funkcji f6(x)')
plt.show()
x_vals_mf6 = np.linspace(-7, 2, 100)
plt.plot(x_vals_mf6, mf6(x_vals_mf6), label='mf6(x)')
plt.ylim(-5, 6)
plt.title('Wykres funkcji mf6(x)')
plt.show()
# Wywołanie metody bisekcji dla df6 i mdf6
bisection_result_df6 = bisection(df6, 0, 2, 0.001)
print("Wynik dla df6:", bisection_result_df6)
bisection_result_mdf6 = bisection(mdf6, -2.5, 0, 0.001)
print("Wynik dla mdf6:", bisection_result_mdf6)



import numpy as np
import matplotlib.pyplot as plt

# Definicja funkcji
def f6(x):
    return (x**3 - 3) * np.exp(x)

def df6(x):
    return np.exp(x) * (x**3 + 3*x**2 - 3)

# Implementacja metody bisekcji z dodatkowym rysowaniem kropki w miejscu minimum
def bisection_with_plot(df, lower, upper, tol):
    iteracja = 1
    while (upper - lower > 2 * tol):
        m = (lower + upper) / 2
        df_m = df(m)

        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)

        if df_m < 0:
            lower = m
        else:
            upper = m

        iteracja += 1

    minimum_x = (upper + lower) / 2
    print("Znalezione minimum dla df6:", minimum_x)

    # Rysowanie wykresu z czerwoną kropką w miejscu minimum
    x_vals = np.linspace(lower - 1, upper + 1, 100)
    plt.plot(x_vals, f6(x_vals), label='f6(x)')
    plt.scatter(minimum_x, f6(minimum_x), color='red', label='Minimum')
    plt.ylim(min(f6(x_vals)), max(f6(x_vals)))
    plt.title('Wykres funkcji f6(x) z zaznaczonym minimum')
    plt.legend()
    plt.show()

    return minimum_x

# Wywołanie metody bisekcji z rysowaniem
bisection_result_df6 = bisection_with_plot(df6, -1, 3, 0.0001)

import numpy as np
import matplotlib.pyplot as plt

# Definicja funkcji
def f6(x):
    return (x**3 - 3) * np.exp(x)

def df6(x):
    return np.exp(x) * (x**3 + 3*x**2 - 3)

# Implementacja metody bisekcji z dodatkowym rysowaniem trajektorii i minimum
def bisection_with_plot(df, lower, upper, tol):
    iteracja = 1
    trajectory = []  # Lista przechowująca punkty trajektorii optymalizacji

    while (upper - lower > 2 * tol):
        m = (lower + upper) / 2
        df_m = df(m)

        while df_m == 0:
            m = (lower + upper) / 2 + np.random.uniform(-tol, tol)
            df_m = df(m)

        if df_m < 0:
            lower = m
        else:
            upper = m

        trajectory.append((m, f6(m)))  # Dodanie punktu do trajektorii optymalizacji
        iteracja += 1

    minimum_x = (upper + lower) / 2
    print("Znalezione minimum dla df6:", minimum_x)

    # Rysowanie wykresu z trajektorią i czerwoną kropką w miejscu minimum
    x_vals = np.linspace(min(trajectory)[0] - 1, max(trajectory)[0] + 1, 100)
    plt.plot(x_vals, f6(x_vals), label='f6(x)')
    plt.scatter(minimum_x, f6(minimum_x), color='red', label='Minimum')

    # Rysowanie trajektorii optymalizacji
    trajectory = np.array(trajectory)
    plt.plot(trajectory[:, 0], trajectory[:, 1], color='green', marker='o', linestyle='dashed', label='Trajektoria optymalizacji')

    plt.ylim(min(f6(x_vals)), max(f6(x_vals)))
    plt.title('Wykres funkcji f6(x) z trajektorią optymalizacji')
    plt.legend()
    plt.show()

    return minimum_x

# Wywołanie metody bisekcji z rysowaniem
bisection_result_df6 = bisection_with_plot(df6, 0, 2, 0.001)
