# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nJwasVKru3otLmhcFFPRqGKcAt7OEGdI
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# Przykładowa funkcja celu do zminimalizowania
def funkcja_celu(x):
    return x**2 + 5*np.sin(x)

# Początkowe przybliżenie
x0 = 0

# Użycie metody minimize do znalezienia optymalnego rozwiązania
wynik = minimize(funkcja_celu, x0, method='BFGS')

# Wizualizacja funkcji celu i znalezionego minimum
x_vals = np.linspace(-5, 5, 100)
y_vals = funkcja_celu(x_vals)

plt.plot(x_vals, y_vals, label='Funkcja celu')
plt.scatter(wynik.x, wynik.fun, color='red', label='Minimum globalne')
plt.xlabel('x')
plt.ylabel('Wartość funkcji celu')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Parametry algorytmu genetycznego
rozmiar_populacji = 100
liczba_generacji = 50
szansa_mutacji = 0.1
najlepszy_osobnik = []


# Funkcja celu (minimalizujemy)
def funkcja_celu(x):
    return x**2 + 5*np.sin(x)

# Inicjalizacja populacji początkowej
populacja = np.random.uniform(-10, 10, rozmiar_populacji)

# Funkcja oceny przystosowania
def ocena_przystosowania(populacja):
    return funkcja_celu(populacja)

# Główna pętla algorytmu genetycznego
for generacja in range(liczba_generacji):
    # Ocena przystosowania
    przystosowanie = ocena_przystosowania(populacja)

    # Wybór najlepszych osobników
    indeksy_najlepszych = np.argsort(przystosowanie)
    najlepsi = populacja[indeksy_najlepszych[:rozmiar_populacji//2]]

    # Krzyżowanie
    potomkowie = np.concatenate([np.random.choice(najlepsi, rozmiar_populacji//2),
                                  np.random.choice(najlepsi, rozmiar_populacji//2)])

    # Mutacja
    maska_mutacji = np.random.rand(rozmiar_populacji) < szansa_mutacji
    potomkowie += maska_mutacji * np.random.uniform(-0.5, 0.5, rozmiar_populacji)

    # Zastąpienie starej populacji nową
    populacja[indeksy_najlepszych] = potomkowie

    indeks_najlepszego = np.argmin(przystosowanie)
    najlepszy_osobnik.append(populacja[indeks_najlepszego])


# Wizualizacja wyników
x_vals = np.linspace(-10, 10, 100)
y_vals = funkcja_celu(x_vals)

plt.plot(x_vals, y_vals, label='Funkcja celu')
plt.scatter(populacja, ocena_przystosowania(populacja), color='red', label='Populacja końcowa')
plt.title('Algorytm Genetyczny - Minimalizacja funkcji celu')
plt.xlabel('x')
plt.ylabel('Wartość funkcji celu')
plt.legend()
plt.show()
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

przystosowanie = ocena_przystosowania(populacja)
ax.scatter(populacja, przystosowanie, generacja, c=przystosowanie, cmap='viridis')

ax.set_xlabel('x')
ax.set_ylabel('Wartość funkcji celu')
ax.set_zlabel('Generacja')
ax.set_title('Wizualizacja populacji w trakcie ewolucji')
plt.show()



plt.plot(range(liczba_generacji), najlepszy_osobnik, marker='o')
plt.xlabel('Generacja')
plt.ylabel('Wartość najlepszego osobnika')
plt.title('Ewolucja najlepszego osobnika')
plt.show()

plt.hist(przystosowanie, bins=20, color='skyblue', edgecolor='black')
plt.xlabel('Wartość funkcji celu')
plt.ylabel('Liczba osobników')
plt.title('Rozkład przystosowania w populacji')
plt.show()

plt.scatter(najlepsi, ocena_przystosowania(najlepsi), label='Najlepsi')
plt.scatter(potomkowie, ocena_przystosowania(potomkowie), color='red', label='Potomkowie')
plt.title('Krzyżowanie i mutacja')
plt.xlabel('x')
plt.ylabel('Wartość funkcji celu')
plt.legend()
plt.show()